{"ast":null,"code":"import _defineProperty from \"C:/pproject-files/new-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"C:/pproject-files/new-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridEvents } from '../../../models/events';\nimport { checkGridRowIdIsValid } from '../../../models/gridRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\n\nfunction getGridRowId(rowModel, getRowId, detailErrorMessage) {\n  var id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n}\n\nvar convertGridRowsPropToState = function convertGridRowsPropToState(_ref) {\n  var prevState = _ref.prevState,\n      rows = _ref.rows,\n      getRowId = _ref.getRowId;\n  var value;\n\n  if (rows) {\n    value = {\n      idRowsLookup: {},\n      ids: []\n    };\n\n    for (var i = 0; i < rows.length; i += 1) {\n      var row = rows[i];\n      var id = getGridRowId(row, getRowId);\n      value.idRowsLookup[id] = row;\n      value.ids.push(id);\n    }\n  } else {\n    value = prevState.value;\n  }\n\n  return {\n    value: value,\n    rowsBeforePartialUpdates: rows != null ? rows : prevState.rowsBeforePartialUpdates\n  };\n};\n\nvar getRowsStateFromCache = function getRowsStateFromCache(rowsCache, previousTree, apiRef, rowCountProp) {\n  var value = rowsCache.state.value;\n  var rowCount = rowCountProp != null ? rowCountProp : 0;\n  var groupingResponse = apiRef.current.unstable_groupRows(_extends({}, value, {\n    previousTree: previousTree\n  }));\n  var dataTopLevelRowCount = groupingResponse.treeDepth === 1 ? groupingResponse.ids.length : Object.values(groupingResponse.tree).filter(function (node) {\n    return node.parent == null;\n  }).length;\n  return _extends({}, groupingResponse, {\n    totalRowCount: Math.max(rowCount, groupingResponse.ids.length),\n    totalTopLevelRowCount: Math.max(rowCount, dataTopLevelRowCount)\n  });\n};\n\nexport var rowsStateInitializer = function rowsStateInitializer(state, props, apiRef) {\n  var rowsCache = {\n    state: convertGridRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevState: {\n        value: {\n          idRowsLookup: {},\n          ids: []\n        },\n        rowsBeforePartialUpdates: []\n      }\n    }),\n    timeout: null,\n    lastUpdateMs: Date.now()\n  };\n  return _extends({}, state, {\n    rows: getRowsStateFromCache(rowsCache, null, apiRef, props.rowCount),\n    rowsCache: rowsCache // TODO remove from state\n\n  });\n};\n/**\n * @requires useGridRowGroupsPreProcessing (method)\n */\n\nexport var useGridRows = function useGridRows(apiRef, props) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Freeze rows for immutability\n    Object.freeze(props.rows);\n  }\n\n  var logger = useGridLogger(apiRef, 'useGridRows');\n  var rowsCache = React.useRef(apiRef.current.state.rowsCache); // To avoid listing rowsCache as useEffect dep\n\n  var currentPage = useGridVisibleRows(apiRef, props);\n  var getRow = React.useCallback(function (id) {\n    var _gridRowsLookupSelect;\n\n    return (_gridRowsLookupSelect = gridRowsLookupSelector(apiRef)[id]) != null ? _gridRowsLookupSelect : null;\n  }, [apiRef]);\n  var lookup = React.useMemo(function () {\n    return currentPage.rows.reduce(function (acc, _ref2, index) {\n      var id = _ref2.id;\n      acc[id] = index;\n      return acc;\n    }, {});\n  }, [currentPage.rows]);\n  var getRowIndexRelativeToVisibleRows = React.useCallback(function (id) {\n    return lookup[id];\n  }, [lookup]);\n  var throttledRowsChange = React.useCallback(function (newState, throttle) {\n    var run = function run() {\n      rowsCache.current.timeout = null;\n      rowsCache.current.lastUpdateMs = Date.now();\n      apiRef.current.setState(function (state) {\n        return _extends({}, state, {\n          rows: getRowsStateFromCache(rowsCache.current, gridRowTreeSelector(apiRef), apiRef, props.rowCount)\n        });\n      });\n      apiRef.current.publishEvent(GridEvents.rowsSet);\n      apiRef.current.forceUpdate();\n    };\n\n    if (rowsCache.current.timeout) {\n      clearTimeout(rowsCache.current.timeout);\n    }\n\n    rowsCache.current.state = newState;\n    rowsCache.current.timeout = null;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    var throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - rowsCache.current.lastUpdateMs);\n\n    if (throttleRemainingTimeMs > 0) {\n      rowsCache.current.timeout = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, apiRef]);\n  var setRows = React.useCallback(function (rows) {\n    logger.debug(\"Updating all rows, new length \".concat(rows.length));\n    throttledRowsChange(convertGridRowsPropToState({\n      rows: rows,\n      prevState: rowsCache.current.state,\n      getRowId: props.getRowId\n    }), true);\n  }, [logger, props.getRowId, throttledRowsChange]);\n  var updateRows = React.useCallback(function (updates) {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to the DataGridPro component to unlock this feature.'].join('\\n'));\n    } // we removes duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    var uniqUpdates = new Map();\n    updates.forEach(function (update) {\n      var id = getGridRowId(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqUpdates.has(id)) {\n        uniqUpdates.set(id, _extends({}, uniqUpdates.get(id), update));\n      } else {\n        uniqUpdates.set(id, update);\n      }\n    });\n    var deletedRowIds = [];\n    var newStateValue = {\n      idRowsLookup: _extends({}, rowsCache.current.state.value.idRowsLookup),\n      ids: _toConsumableArray(rowsCache.current.state.value.ids)\n    };\n    uniqUpdates.forEach(function (partialRow, id) {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newStateValue.idRowsLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      var oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newStateValue.idRowsLookup[id] = partialRow;\n        newStateValue.ids.push(id);\n        return;\n      }\n\n      newStateValue.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newStateValue.ids = newStateValue.ids.filter(function (id) {\n        return !deletedRowIds.includes(id);\n      });\n    }\n\n    var state = _extends({}, rowsCache.current.state, {\n      value: newStateValue\n    });\n\n    throttledRowsChange(state, true);\n  }, [apiRef, props.getRowId, throttledRowsChange, props.signature]);\n  var getRowModels = React.useCallback(function () {\n    var allRows = gridRowIdsSelector(apiRef);\n    var idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(function (id) {\n      return [id, idRowsLookup[id]];\n    }));\n  }, [apiRef]);\n  var getRowsCount = React.useCallback(function () {\n    return gridRowCountSelector(apiRef);\n  }, [apiRef]);\n  var getAllRowIds = React.useCallback(function () {\n    return gridRowIdsSelector(apiRef);\n  }, [apiRef]);\n  var setRowChildrenExpansion = React.useCallback(function (id, isExpanded) {\n    var currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(\"MUI: No row with id #\".concat(id, \" found\"));\n    }\n\n    var newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, _defineProperty({}, id, newNode))\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent(GridEvents.rowExpansionChange, newNode);\n  }, [apiRef]);\n  var getRowNode = React.useCallback(function (id) {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  React.useEffect(function () {\n    return function () {\n      if (rowsCache.current.timeout !== null) {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        clearTimeout(rowsCache.current.timeout);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  var isFirstRender = React.useRef(true);\n  React.useEffect(function () {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    } // The new rows have already been applied (most likely in the `GridEvents.rowGroupsPreProcessingChange` listener)\n\n\n    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {\n      return;\n    }\n\n    logger.debug(\"Updating all rows, new length \".concat(props.rows.length));\n    throttledRowsChange(convertGridRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevState: rowsCache.current.state\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, logger, throttledRowsChange]);\n  var handleGroupRows = React.useCallback(function () {\n    logger.info(\"Row grouping pre-processing have changed, regenerating the row tree\");\n    var rows;\n\n    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` has not changed since the last row grouping\n      // We can keep the potential updates stored in `inputRowsAfterUpdates` on the new grouping\n      rows = undefined;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      rows = props.rows;\n    }\n\n    throttledRowsChange(convertGridRowsPropToState({\n      rows: rows,\n      getRowId: props.getRowId,\n      prevState: rowsCache.current.state\n    }), false);\n  }, [logger, throttledRowsChange, props.getRowId, props.rows]);\n  useGridApiEventHandler(apiRef, GridEvents.rowGroupsPreProcessingChange, handleGroupRows);\n  var rowApi = {\n    getRow: getRow,\n    getRowModels: getRowModels,\n    getRowsCount: getRowsCount,\n    getAllRowIds: getAllRowIds,\n    setRows: setRows,\n    updateRows: updateRows,\n    setRowChildrenExpansion: setRowChildrenExpansion,\n    getRowNode: getRowNode,\n    getRowIndexRelativeToVisibleRows: getRowIndexRelativeToVisibleRows\n  };\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n};","map":{"version":3,"sources":["C:/pproject-files/new-app/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js"],"names":["_extends","React","GridEvents","checkGridRowIdIsValid","useGridApiMethod","useGridLogger","gridRowCountSelector","gridRowsLookupSelector","gridRowTreeSelector","gridRowIdsSelector","GridSignature","useGridApiEventHandler","useGridVisibleRows","getGridRowId","rowModel","getRowId","detailErrorMessage","id","convertGridRowsPropToState","prevState","rows","value","idRowsLookup","ids","i","length","row","push","rowsBeforePartialUpdates","getRowsStateFromCache","rowsCache","previousTree","apiRef","rowCountProp","state","rowCount","groupingResponse","current","unstable_groupRows","dataTopLevelRowCount","treeDepth","Object","values","tree","filter","node","parent","totalRowCount","Math","max","totalTopLevelRowCount","rowsStateInitializer","props","timeout","lastUpdateMs","Date","now","useGridRows","process","env","NODE_ENV","freeze","logger","useRef","currentPage","getRow","useCallback","_gridRowsLookupSelect","lookup","useMemo","reduce","acc","index","getRowIndexRelativeToVisibleRows","throttledRowsChange","newState","throttle","run","setState","publishEvent","rowsSet","forceUpdate","clearTimeout","throttleRemainingTimeMs","throttleRowsMs","setTimeout","setRows","debug","updateRows","updates","signature","DataGrid","Error","join","uniqUpdates","Map","forEach","update","has","set","get","deletedRowIds","newStateValue","partialRow","_action","oldRow","includes","getRowModels","allRows","map","getRowsCount","getAllRowIds","setRowChildrenExpansion","isExpanded","currentNode","getRowNode","newNode","childrenExpanded","rowExpansionChange","_gridRowTreeSelector$","useEffect","isFirstRender","handleGroupRows","info","undefined","rowGroupsPreProcessingChange","rowApi"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridEvents } from '../../../models/events';\nimport { checkGridRowIdIsValid } from '../../../models/gridRows';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\n\nfunction getGridRowId(rowModel, getRowId, detailErrorMessage) {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n}\n\nconst convertGridRowsPropToState = ({\n  prevState,\n  rows,\n  getRowId\n}) => {\n  let value;\n\n  if (rows) {\n    value = {\n      idRowsLookup: {},\n      ids: []\n    };\n\n    for (let i = 0; i < rows.length; i += 1) {\n      const row = rows[i];\n      const id = getGridRowId(row, getRowId);\n      value.idRowsLookup[id] = row;\n      value.ids.push(id);\n    }\n  } else {\n    value = prevState.value;\n  }\n\n  return {\n    value,\n    rowsBeforePartialUpdates: rows != null ? rows : prevState.rowsBeforePartialUpdates\n  };\n};\n\nconst getRowsStateFromCache = (rowsCache, previousTree, apiRef, rowCountProp) => {\n  const {\n    value\n  } = rowsCache.state;\n  const rowCount = rowCountProp != null ? rowCountProp : 0;\n  const groupingResponse = apiRef.current.unstable_groupRows(_extends({}, value, {\n    previousTree\n  }));\n  const dataTopLevelRowCount = groupingResponse.treeDepth === 1 ? groupingResponse.ids.length : Object.values(groupingResponse.tree).filter(node => node.parent == null).length;\n  return _extends({}, groupingResponse, {\n    totalRowCount: Math.max(rowCount, groupingResponse.ids.length),\n    totalTopLevelRowCount: Math.max(rowCount, dataTopLevelRowCount)\n  });\n};\n\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  const rowsCache = {\n    state: convertGridRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevState: {\n        value: {\n          idRowsLookup: {},\n          ids: []\n        },\n        rowsBeforePartialUpdates: []\n      }\n    }),\n    timeout: null,\n    lastUpdateMs: Date.now()\n  };\n  return _extends({}, state, {\n    rows: getRowsStateFromCache(rowsCache, null, apiRef, props.rowCount),\n    rowsCache // TODO remove from state\n\n  });\n};\n/**\n * @requires useGridRowGroupsPreProcessing (method)\n */\n\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    // Freeze rows for immutability\n    Object.freeze(props.rows);\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const rowsCache = React.useRef(apiRef.current.state.rowsCache); // To avoid listing rowsCache as useEffect dep\n\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const getRow = React.useCallback(id => {\n    var _gridRowsLookupSelect;\n\n    return (_gridRowsLookupSelect = gridRowsLookupSelector(apiRef)[id]) != null ? _gridRowsLookupSelect : null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const throttledRowsChange = React.useCallback((newState, throttle) => {\n    const run = () => {\n      rowsCache.current.timeout = null;\n      rowsCache.current.lastUpdateMs = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache(rowsCache.current, gridRowTreeSelector(apiRef), apiRef, props.rowCount)\n      }));\n      apiRef.current.publishEvent(GridEvents.rowsSet);\n      apiRef.current.forceUpdate();\n    };\n\n    if (rowsCache.current.timeout) {\n      clearTimeout(rowsCache.current.timeout);\n    }\n\n    rowsCache.current.state = newState;\n    rowsCache.current.timeout = null;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - rowsCache.current.lastUpdateMs);\n\n    if (throttleRemainingTimeMs > 0) {\n      rowsCache.current.timeout = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, apiRef]);\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    throttledRowsChange(convertGridRowsPropToState({\n      rows,\n      prevState: rowsCache.current.state,\n      getRowId: props.getRowId\n    }), true);\n  }, [logger, props.getRowId, throttledRowsChange]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to the DataGridPro component to unlock this feature.'].join('\\n'));\n    } // we removes duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    const uniqUpdates = new Map();\n    updates.forEach(update => {\n      const id = getGridRowId(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqUpdates.has(id)) {\n        uniqUpdates.set(id, _extends({}, uniqUpdates.get(id), update));\n      } else {\n        uniqUpdates.set(id, update);\n      }\n    });\n    const deletedRowIds = [];\n    const newStateValue = {\n      idRowsLookup: _extends({}, rowsCache.current.state.value.idRowsLookup),\n      ids: [...rowsCache.current.state.value.ids]\n    };\n    uniqUpdates.forEach((partialRow, id) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newStateValue.idRowsLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      const oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newStateValue.idRowsLookup[id] = partialRow;\n        newStateValue.ids.push(id);\n        return;\n      }\n\n      newStateValue.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newStateValue.ids = newStateValue.ids.filter(id => !deletedRowIds.includes(id));\n    }\n\n    const state = _extends({}, rowsCache.current.state, {\n      value: newStateValue\n    });\n\n    throttledRowsChange(state, true);\n  }, [apiRef, props.getRowId, throttledRowsChange, props.signature]);\n  const getRowModels = React.useCallback(() => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(id => [id, idRowsLookup[id]]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent(GridEvents.rowExpansionChange, newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  React.useEffect(() => {\n    return () => {\n      if (rowsCache.current.timeout !== null) {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        clearTimeout(rowsCache.current.timeout);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    } // The new rows have already been applied (most likely in the `GridEvents.rowGroupsPreProcessingChange` listener)\n\n\n    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {\n      return;\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange(convertGridRowsPropToState({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      prevState: rowsCache.current.state\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, logger, throttledRowsChange]);\n  const handleGroupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let rows;\n\n    if (rowsCache.current.state.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` has not changed since the last row grouping\n      // We can keep the potential updates stored in `inputRowsAfterUpdates` on the new grouping\n      rows = undefined;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      rows = props.rows;\n    }\n\n    throttledRowsChange(convertGridRowsPropToState({\n      rows,\n      getRowId: props.getRowId,\n      prevState: rowsCache.current.state\n    }), false);\n  }, [logger, throttledRowsChange, props.getRowId, props.rows]);\n  useGridApiEventHandler(apiRef, GridEvents.rowGroupsPreProcessingChange, handleGroupRows);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    updateRows,\n    setRowChildrenExpansion,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows\n  };\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n};"]},"metadata":{},"sourceType":"module"}